# https://contest.yandex.ru/contest/23759/problems/B/

# B. Калькулятор
# Ограничение времени	1 секунда
# Ограничение памяти	64Mb
# Ввод	стандартный ввод или input.txt
# Вывод	стандартный вывод или output.txt
# Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Еще её иногда называют постфиксной нотацией.

# В постфиксной нотации операнды расположены перед знаками операций.

# Пример 1:
# 3 4 +
# означает 3 + 4 и равно 7

# Пример 2:
# 12 5 /
# Так как деление целочисленное, то в результате получим 2.

# Пример 3:
# 10 2 4 * -
# означает 10 - 2 * 4 и равно 2

# Разберём последний пример подробнее:

# Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает, то есть перемножить эти два числа. В результате получим 8.

# После этого выражение приобретёт вид:

# 10 8 -

# Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.

# Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

# Для вычисления значения выражения, записанного в обратной польской нотации, нужно считывать выражение слева направо и придерживаться следующих шагов:

# Обработка входного символа:
# Если на вход подан операнд, он помещается на вершину стека.
# Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений, взятых из стека в порядке добавления. Результат выполненной операции помещается на вершину стека.
# Если входной набор символов обработан не полностью, перейти к шагу 1.
# После полной обработки входного набора символов результат вычисления выражения находится в вершине стека. Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.
# Замечание про отрицательные числа и деление: в этой задаче под делением понимается математическое целочисленное деление. Это значит, что округление всегда происходит вниз. А именно: если a / b = c, то b ⋅ c — это наибольшее число, которое не превосходит a и одновременно делится без остатка на b.

# Например, -1 / 3 = -1. Будьте осторожны: в C++, Java и Go, например, деление чисел работает иначе.

# В текущей задаче гарантируется, что деления на отрицательное число нет.

# Формат ввода
# В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции записаны через пробел.

# На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.

# Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

# Формат вывода
# Выведите единственное число — значение выражения.


class StackDigits:
    def __init__(self):
        self.items = []

    def __str__(self):
        return ' '.join(str(x) for x in self.items)
        # return self.items

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if self.items:
            return self.items.pop()
        else:
            return 'error'


def exp_stack(exp, digits):
    # print('exp_stack exp=', exp)
    # print('exp_stack digits=', digits)
    if (exp == '+'):
        b = digits.pop()
        a = digits.pop()
        return a + b
    elif (exp == '-'):
        b = digits.pop()
        a = digits.pop()
        return a - b
    elif (exp == '*'):
        b = digits.pop()
        a = digits.pop()
        return a * b
    elif (exp == '/'):
        b = digits.pop()
        a = digits.pop()
        return a // b
    else:
        return None


def polish_calc(exp_list):
    result = list(exp_list)
    # print(result)

    digits = StackDigits()

    result = 0
    for i in exp_list:
        if i.isdigit() or i.lstrip("-").isdigit():
            digits.push(int(i))
            result = int(i)
        else:
            result = exp_stack(i, digits)
            digits.push(result)
    return result


if __name__ == '__main__':
    file = open("input.txt", "r")
    # В единственной строке дано выражение в обратной польской нотации.
    exp_list = tuple(map(str, file.readline().split()))
    file.close()
    result = polish_calc(exp_list)
    print(result)
